{"meta":{"title":"LiYang","subtitle":null,"description":null,"author":"LiYang","url":"https://lisunny.github.io","root":"/liyang.github.io/"},"pages":[{"title":"Tags","date":"2019-09-09T07:26:27.000Z","updated":"2019-09-09T08:08:35.360Z","comments":true,"path":"tags/index.html","permalink":"https://lisunny.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-09-09T08:09:28.000Z","updated":"2019-09-09T08:09:44.690Z","comments":true,"path":"categories/index.html","permalink":"https://lisunny.github.io/categories/index.html","excerpt":"","text":""},{"title":"/效率工具","date":"2019-09-09T03:24:30.000Z","updated":"2019-09-09T03:24:30.085Z","comments":true,"path":"效率工具/index.html","permalink":"https://lisunny.github.io/效率工具/index.html","excerpt":"","text":""}],"posts":[{"title":"物联网平台（维保模块)使用手册","slug":"物联网平台（维保模块-使用手册","date":"2020-03-13T00:56:23.000Z","updated":"2020-03-13T01:09:37.766Z","comments":true,"path":"2020/03/13/物联网平台（维保模块-使用手册/","link":"","permalink":"https://lisunny.github.io/2020/03/13/物联网平台（维保模块-使用手册/","excerpt":"物联网平台App巡检模块使用手册使用环境介绍Android6.0及以上功能介绍维保完成率统计首页显示已完成维保计划总数、处理工单总数及完成率（完成率只统计当前可执行任务完成率）维保任务维保任务列表 展示当前可执行的维保任务 可通过关键字搜索维保任务 可通过维保频率筛选维保任务 点击维保任务记录中的开始按钮开始维保任务","text":"物联网平台App巡检模块使用手册使用环境介绍Android6.0及以上功能介绍维保完成率统计首页显示已完成维保计划总数、处理工单总数及完成率（完成率只统计当前可执行任务完成率）维保任务维保任务列表 展示当前可执行的维保任务 可通过关键字搜索维保任务 可通过维保频率筛选维保任务 点击维保任务记录中的开始按钮开始维保任务 执行维保任务 可输入总工时（必须） 可输入内容描述 可选择添加维保过程中使用的耗材（详细说明见添加耗材说明） 可上传图片、视频附件 可手动入场打卡（如点击入场打卡，实时显示入场时间；即使返回上一页再次进入处理页仍可显示入场时间且不在显示入场打卡按钮） 维保计划维保计划列表 可显示所有指定给登录用户的维保计划 可通过关键字搜索维保计划 可显示该计划的最近完成时间 维保任务 显示基于计划已生成的维保任务 可显示任务完成情况（==已完成== ==未完成==） 可显示维保任务状态（==正常== ==异常：已超期 或 超期完成==） 工单处理工单列表 显示当前==已受理==、==待确认==、==已完成==三种状态的工单 如已完成，显示完成时间 ==已完成==、==待确认==状态工单可点击查看详情 ==待处理==状态点击可进行工单处理 工单处理 可输入总工时（必须） 可输入内容描述 可选择添加维保过程中使用的耗材（详细说明见添加耗材说明） 可上传图片、视频及语音附件 可手动入场打卡（如点击入场打卡，实时显示入场时间；即使返回上一页再次进入处理页仍可显示入场时间且不在显示入场打卡按钮） 添加耗材耗材列表 仅展示本中心Web端维护的耗材信息 可通过耗材关键字搜索耗材 可通过点击加号添加耗材，同时支持直接编辑数量 耗材结算 可增加、减少耗材数量 可删除耗材 可修改、编辑实际支付金额 实时显示应付总金额及实付金额","categories":[{"name":"Android","slug":"Android","permalink":"https://lisunny.github.io/categories/Android/"}],"tags":[{"name":"使用手册","slug":"使用手册","permalink":"https://lisunny.github.io/tags/使用手册/"}]},{"title":"UIButton的EdgeInsets相关理解","slug":"UIButton的EdgeInsets相关理解","date":"2019-09-30T08:47:42.000Z","updated":"2019-09-30T08:54:25.080Z","comments":true,"path":"2019/09/30/UIButton的EdgeInsets相关理解/","link":"","permalink":"https://lisunny.github.io/2019/09/30/UIButton的EdgeInsets相关理解/","excerpt":"","text":"实例代码官方文档1234567891011121314151617181920//位移是基于相对视图位置（与autolayout类似） 基于之前位置的相对左右上下的偏移量（不存在坐标系这一说法）例如bottom 只是设置相对偏移量而物理坐标值//负数是相对边界外扩 正数是相对边界内收 且实际移动距离是设置距离的一半let vSpace = (contentRect.size.height - titleRect.size.height - imageRect.size.height)/3.0let lableCenterX = titleRect.midXlet imageCenterX = imageRect.midXlet btnCenterX = backBtn.bounds.midXlet btnCenterY = backBtn.bounds.midYlet imageLeftInset = (btnCenterX - imageCenterX)*2let imageTopInset = -((btnCenterY - (vSpace + (backBtn.imageView?.bounds.size.height)!/2.0))*2)let titleLeftInset = (btnCenterX - lableCenterX)*2let titleBottomInset = imageTopInsetbackBtn.imageEdgeInsets = UIEdgeInsets.init(top:imageTopInset, left: imageLeftInset, bottom: 0, right:0)backBtn.titleEdgeInsets = UIEdgeInsets.init(top: 0, left: titleLeftInset, bottom: titleBottomInset, right: 0)","categories":[{"name":"iOS","slug":"iOS","permalink":"https://lisunny.github.io/categories/iOS/"}],"tags":[{"name":"EdgeInsets","slug":"EdgeInsets","permalink":"https://lisunny.github.io/tags/EdgeInsets/"}]},{"title":"数据库相关API操作","slug":"数据库相关API操作","date":"2019-09-19T07:24:44.000Z","updated":"2019-09-19T07:24:44.473Z","comments":true,"path":"2019/09/19/数据库相关API操作/","link":"","permalink":"https://lisunny.github.io/2019/09/19/数据库相关API操作/","excerpt":"在应用程序中有时因为业务需要，可能会在本地创建一个小型数据库，这时候就不得不用到Android原生的数据库操作库android.database和android.database.sqlite,事实上这两个工具库是有不同的应用场景的，如官方文档所说:android.database.sqliteOverview1234Contains the SQLite database management classes that an application would use to manage its own private database.Applications use these classes to manage private databases. If creating a content provider, you will probably have to use these classes to create and manage your own database to store content. See Content Providers to learn the conventions for implementing a content provider. If you are working with data sent to you by a provider, you do not use these SQLite classes, but instead use the generic android.database classes.","text":"在应用程序中有时因为业务需要，可能会在本地创建一个小型数据库，这时候就不得不用到Android原生的数据库操作库android.database和android.database.sqlite,事实上这两个工具库是有不同的应用场景的，如官方文档所说:android.database.sqliteOverview1234Contains the SQLite database management classes that an application would use to manage its own private database.Applications use these classes to manage private databases. If creating a content provider, you will probably have to use these classes to create and manage your own database to store content. See Content Providers to learn the conventions for implementing a content provider. If you are working with data sent to you by a provider, you do not use these SQLite classes, but instead use the generic android.database classes. android.databaseandroid.database.sqliteSqliteDatabase数据库管理类，可用来创建、删除、执行SQL命令和其他常见数据库管理任务;常用的数据库操作增删改查都有提供相应的SQL语句方法和Android重新封装方法，可以说是肥肠滴方便。 SQLite语句方法在官方文档中rawQuery开头的方法都支持SQLite语句方式做数据库的修改，例如： rawQueryAdded in API level 112undefined Android方法增往数据库中插入一行 插入Added in API level 1123undefined返回新插入行**ID**，如果返回&lt;span class=&quot;label warning&quot;&gt;-1&lt;/span&gt;则未成功 删删除数据库中某一行数据 删除Added in API level 1123undefined返回删除结果，如果返回&lt;span class=&quot;label warning&quot;&gt;0&lt;/span&gt;则删除单行成功，如果返回&lt;span class=&quot;label warning&quot;&gt;1&lt;/span&gt;则删除所有行成功 改修改数据库中某一行数据 修改Added in API level 1123undefined返回修改行总数 查查看数据库 查看Added in API level 1123undefined返回查看游标 SQLiteOpenHelper","categories":[{"name":"Android","slug":"Android","permalink":"https://lisunny.github.io/categories/Android/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://lisunny.github.io/tags/数据库/"},{"name":"Sqlite3","slug":"Sqlite3","permalink":"https://lisunny.github.io/tags/Sqlite3/"}]},{"title":"苹果开发者账号维护记录","slug":"苹果开发者账号维护记录","date":"2019-09-19T05:29:01.000Z","updated":"2019-09-19T05:30:35.410Z","comments":true,"path":"2019/09/19/苹果开发者账号维护记录/","link":"","permalink":"https://lisunny.github.io/2019/09/19/苹果开发者账号维护记录/","excerpt":"目前项目使用的Bundle Identifier情况 Bundle Identifier 描述 com.neat.peace 小尼平安 推送相关目前推送使用的是极光推送的是Token Authentication作为鉴权方式，配置简单、方便且不用考虑证书过期要重新上传证书的问题 要注意的是 key一旦被下载就无法重复下载","text":"目前项目使用的Bundle Identifier情况 Bundle Identifier 描述 com.neat.peace 小尼平安 推送相关目前推送使用的是极光推送的是Token Authentication作为鉴权方式，配置简单、方便且不用考虑证书过期要重新上传证书的问题 要注意的是 key一旦被下载就无法重复下载 账号使用情况目前所有项目均在xfliyang@163.neat.cn账户下使用，一个人维护暂不开设子账号；后期可在Xcode中进行账号的维护","categories":[{"name":"iOS","slug":"iOS","permalink":"https://lisunny.github.io/categories/iOS/"}],"tags":[{"name":"开发者账号","slug":"开发者账号","permalink":"https://lisunny.github.io/tags/开发者账号/"}]},{"title":"URI与URi傻傻分不清楚？","slug":"URI与URi傻傻分不清楚？","date":"2019-09-11T07:14:07.000Z","updated":"2019-09-12T02:44:31.404Z","comments":true,"path":"2019/09/11/URI与URi傻傻分不清楚？/","link":"","permalink":"https://lisunny.github.io/2019/09/11/URI与URi傻傻分不清楚？/","excerpt":"相信在好多时候调用系统页面加载数据时，难免要做URi转Path的操作；尤其是在Android7.0之后，Google更是取消了file://这种方式访问文件，URi(统一资源标识符)便优雅的出现在了开发者的代码中；那URI与URi到底有什么区别和联系呢？让我们看一下两者官方文档的定义之间的对比： URI URi 统一标识符引用，更多的是一种格式规范 不可变的URI引用，可以理解为一个URI的实例，更倾向于指向一种资源","text":"相信在好多时候调用系统页面加载数据时，难免要做URi转Path的操作；尤其是在Android7.0之后，Google更是取消了file://这种方式访问文件，URi(统一资源标识符)便优雅的出现在了开发者的代码中；那URI与URi到底有什么区别和联系呢？让我们看一下两者官方文档的定义之间的对比： URI URi 统一标识符引用，更多的是一种格式规范 不可变的URI引用，可以理解为一个URI的实例，更倾向于指向一种资源 URI在java.net.URI包中，可细分为 absolute URI（绝对URI）基本格式 [scheme:]scheme-specific-part[fragment] opaque URI（不透明URI） 例如：mailto:java-net@java.sun.com hierarchical URI（分级URI）基本格式 [scheme:][//authority][path][?query][fragment] 鉴权URI基本格式 [user-info@]host[:port] URI实例包含一下几种组件： 组件 类型 scheme String scheme-specific-part String authority String user-info String host String port int path String query String fragment String 常用的取组件的方法： 12http://www.java2s.com:8080/yourpath/fileName.html?stove=10&amp;path=32&amp;id=4#harvichttps://liyang@xxx.xxx.xxx.xxx:xxxx/svn/xxxx 方法 描述 getAuthority() 获取Uri中Authority部分 第一个URL的www.java2s.com:8080部分 getFragment() 获取Uri中的Fragment部分 第一个URL的harvic部分 getHost() 获取Authority中的Host字符串 第一个URL的www.java2s.com部分 getPath() 获取Uri中path部分 第一个URL的/yourpath/fileName.html部分 getPort() 获取Authority中的Port字符串 第一个URL的8080部分 getSchemeSpecificPart() 获取Uri中的scheme-specific-part:部分 第一个URL的//www.java2s.com:8080/yourpath/fileName.html?部分 getQuery() 获取Uri中的query部分，第一个URL的stove=10&amp;path=32&amp;id=4部分 getScheme() 获取Uri中的scheme字符串部分 第一个URL的http部分 getUserInfo() 第二个URL的liyang部分 URi在android.net.Uri包中,属于是针对Android做了特殊优化的工具类，URI中常用的取组件方法在URi类中都有，并且还添加了不少更便于使用的方法，有兴趣的可以自己好好研读下官方文档 参考文章： URi详解之——URi结构与代码提取 博文地址blog.csdn.net/harvic880925/article/details/44679239","categories":[{"name":"Android","slug":"Android","permalink":"https://lisunny.github.io/categories/Android/"}],"tags":[{"name":"URI","slug":"URI","permalink":"https://lisunny.github.io/tags/URI/"},{"name":"URi","slug":"URi","permalink":"https://lisunny.github.io/tags/URi/"}]},{"title":"hexo写作指南","slug":"hexo写作指南","date":"2019-09-10T03:07:46.000Z","updated":"2019-09-11T01:08:49.751Z","comments":true,"path":"2019/09/10/hexo写作指南/","link":"","permalink":"https://lisunny.github.io/2019/09/10/hexo写作指南/","excerpt":"Markdown关于Markdown Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 Markdown语法","text":"Markdown关于Markdown Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 Markdown语法 段落与换行 段落的前后必须是空行 空行指的是行内什么都没有，或者只有空白符（空格或制表符）相邻两行文本，如果中间没有空行会显示在一行中（换行符被转换为空格） 标题Markdown语法共支持六级标题，每一级标题对应多少个#符号 标题 语法 一级标题 # 二级标题 ## 三级标题 ### 四级标题 #### 五级标题 ##### 六级标题 ###### 引用引用内容1&gt; 这是一个引用内容 这是一个引用内容 列表有序列表12341. 这是有序列表2. 这是有序列表3. 这是有序列表4. 这是有序列表 这是有序列表 这是有序列表 这是有序列表 这是有序列表 无序列表1234- 这是无序列表- 这是无序列表- 这是无序列表- 这是无序列表 这是无序列表 这是无序列表 这是无序列表 这是无序列表 嵌套列表1234561. 第一层 - 第二层无序 1. 第二层有序- 第一层 - 第二层无序 1. 第二层有序 第一层 第二层无序 第二层有序 第一层 第二层无序 第二层有序 代码块1234567Intent intent = getIntent(); if (intent.hasExtra(videoInfor))&#123; VideoBean videoBean = (VideoBean) intent.getSerializableExtra(videoInfor); appKey = videoBean.resultBean.appKey; token = videoBean.resultBean.accessToken; playUrl = videoBean.resultBean.playURL; &#125; 分割线1231 ***2 ------3 ___ 超链接1[百度一下](http://www.baidu.com) 百度一下 图片1![image1](https://avatars2.githubusercontent.com/u/3265208?v=3&amp;s=100) 强调1234567**加粗***斜体****加粗斜体***~~删除~~ 加粗 斜体 加粗斜体 删除 表格1234name | age---- | ---LearnShare | 12Mike | 32 name age LearnShare 12 Mike 32 TaskList123456- [x] Eat- [ ] Code - [ ] HTML - [ ] CSS - [ ] JavaScript- [ ] Sleep Eat Code HTML CSS JavaScript Sleep Hexo内置标签引用块在文章中插入引言，可包含作者、来源和标题。 123&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content&#123;% endblockquote %&#125; 样例： 没有任何参数 我们每天都该干一两件自己不喜欢的事情，以求心灵平静。 带author及source参数 与其热闹着引人夺目，步步紧逼，不如趋向做一个人群之中真实自然的人，不张扬，不虚饰，随时保持退后的位置。心有所定，只是专注做事。 安妮宝贝《素年锦时》 带author及link参数 这世界是你的遗嘱，而我是你唯一的遗物。 励志网www.qqzf.cn/lizhi61792 带author、link及source_link_title 这世界是你的遗嘱，而我是你唯一的遗物。 励志网《从你的全世界路过》 代码块在文章中插入代码 123&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125; 没有任何参数 1alert(&apos;Hello World!&apos;); 指定语言 1[rectangle setX: 10 y: 10 width: 20 height: 20]; 带title Array.map1array.map(callback[, thisArg]) 带title、链接及文字compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] Pull Quote在文章中插入 Pull quote。 content jsFiddle在文章中嵌入 jsFiddle 引用文章引用其他文章的链接。 12&#123;% post_path slug %&#125;&#123;% post_link slug [title] %&#125; 引用资源引用文章的资源 123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; note标签通过 note 标签可以为段落添加背景色，语法如下： 123&#123;% note [class] %&#125;文本内容 (支持行内标签)&#123;% endnote %&#125; 支持的 class 种类包括 default primary success info warning danger，也可以不指定 class。 default note tag primary note tag success note tag info note tag warning note tag danger note tag 更多配置可在主题配置文件中设置 themes\\next\\_config.yml123456note: # Note 标签样式预设 style: modern # simple | modern | flat | disabled icons: false # 是否显示图标 border_radius: 3 # 圆角半径 light_bg_offset: 0 # 默认背景减淡效果，以百分比计算 文本居中标签居中标签效果如下： 我不去想是否能够成功，既然选择了远方，便只顾风雨兼程。 一般在引用单行文本时使用，如作为文章开篇题词。 可以通过以下几种方式使用该标签： 123456789&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;&lt;!-- 其中 class=&quot;blockquote-center&quot; 是必须的 --&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;blah blah blah&lt;/blockquote&gt;&lt;!-- 标签方式 --&gt;&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;&lt;!-- 标签别名 --&gt;&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125; Lable标签通过 label 标签可以为文字添加背景色，语法如下： 1&#123;% label [class]@text %&#125; 支持的 class 种类包括 default primary success info warning danger，默认使用 default 作为缺省。 示例如下： 123456789I heard the echo, &#123;% label default@from the valleys and the heart %&#125;Open to the lonely soul of &#123;% label info@sickle harvesting %&#125;Repeat outrightly, but also repeat the well-being ofEventually &#123;% label warning@swaying in the desert oasis %&#125;&#123;% label success@I believe %&#125; I am&#123;% label primary@Born as the bright summer flowers %&#125;Do not withered undefeated fiery demon ruleHeart rate and breathing to bear &#123;% label danger@the load of the cumbersome %&#125;Bored I heard the echo, from the valleys and the heart! Open to the lonely soul of sickle harvestingRepeat outrightly, but also repeat the well-being ofEventually swaying in the desert oasis I believe I am Born as the bright summer flowers Do not withered undefeated fiery demon ruleHeart rate and breathing to bear the load of the cumbersomeBored button 按钮通过 button 标签可以快速添加带有主题样式的按钮，语法如下： 1&#123;% button /path/to/url/, text, icon [class], title %&#125; 也可简写为： 1&#123;% btn /path/to/url/, text, icon [class], title %&#125; 其中， 图标 ID 来源于 FontAwesome 。 使用示例如下： 文本 文本 & 标题 文本 & 图标 文本 & 大图标 (固定宽度) tab 标签tab 标签用于快速创建 tab 选项卡，语法如下 12345&#123;% tabs [Unique name], [index] %&#125; &lt;!-- tab [Tab caption]@[icon] --&gt; 标签页内容（支持行内标签） &lt;!-- endtab --&gt;&#123;% endtabs %&#125; 其中，各参数意义如下： Unique name: 全局唯一的 Tab 名称，将作为各个标签页的 id 属性前缀 index: 当前激活的标签页索引，如果未定义则默认选中显示第一个标签页，如果设为 - 1 则默认隐藏所有标签页 Tab caption: 当前标签页的标题，如果不指定则会以 Unique name 加上索引作为标题 icon: 在标签页标题中添加 Font awesome 图标 示例如下： 1234567891011&#123;% tabs Tab标签列表 %&#125; &lt;!-- tab 标签页1 --&gt; 标签页1文本内容 &lt;!-- endtab --&gt; &lt;!-- tab 标签页2 --&gt; 标签页2文本内容 &lt;!-- endtab --&gt; &lt;!-- tab 标签页3 --&gt; 标签页3文本内容 &lt;!-- endtab --&gt;&#123;% endtabs %&#125; JavaObjec-cJavaScriptundefined Intent intent = getIntent(); if (intent.hasExtra(videoInfor)){ VideoBean videoBean = (VideoBean) intent.getSerializableExtra(videoInfor); appKey = videoBean.resultBean.appKey; token = videoBean.resultBean.accessToken; playUrl = videoBean.resultBean.playURL; } Intent intent = getIntent(); if (intent.hasExtra(videoInfor)){ VideoBean videoBean = (VideoBean) intent.getSerializableExtra(videoInfor); appKey = videoBean.resultBean.appKey; token = videoBean.resultBean.accessToken; playUrl = videoBean.resultBean.playURL; }","categories":[{"name":"hexo","slug":"hexo","permalink":"https://lisunny.github.io/categories/hexo/"}],"tags":[{"name":"内置标签","slug":"内置标签","permalink":"https://lisunny.github.io/tags/内置标签/"},{"name":"个人博客写作技巧及元素用法","slug":"个人博客写作技巧及元素用法","permalink":"https://lisunny.github.io/tags/个人博客写作技巧及元素用法/"}]},{"title":"关于Git版本控制的一些想法","slug":"关于Git版本控制的一些想法","date":"2019-09-09T05:48:30.000Z","updated":"2019-09-09T05:49:56.344Z","comments":true,"path":"2019/09/09/关于Git版本控制的一些想法/","link":"","permalink":"https://lisunny.github.io/2019/09/09/关于Git版本控制的一些想法/","excerpt":"一个项目到底要有多少个分支才合适？ 一般情况下独立开发的项目好多人都喜欢用一条分支，简单、粗暴没有那么多的麻烦。但随着一个人负责的项目越来越多、迭代开发越来越多，临时打包的情况时常发生。你想啊！正在写新功能，突然就然你打个包，这酸爽简直不敢想象！所以好的分支管理还是非常有必要的。 现阶段我个人觉得一个项目至少要有2条分支","text":"一个项目到底要有多少个分支才合适？ 一般情况下独立开发的项目好多人都喜欢用一条分支，简单、粗暴没有那么多的麻烦。但随着一个人负责的项目越来越多、迭代开发越来越多，临时打包的情况时常发生。你想啊！正在写新功能，突然就然你打个包，这酸爽简直不敢想象！所以好的分支管理还是非常有必要的。 现阶段我个人觉得一个项目至少要有2条分支 Master分支（主要用来保存经过测试，功能完整，安装即可使用的） Dev分支（主要用来保存开发阶段代码） 各个分支要怎样管理才好？ 开发过程一定是在Dev分支，测试无误，提交至Master分支 Master分支不做修改操作，只是用来保存功能完整的代码 Master分支要做好tag管理，既每测试完成一个版本要做好区分和备份","categories":[{"name":"工作流的思考","slug":"工作流的思考","permalink":"https://lisunny.github.io/categories/工作流的思考/"}],"tags":[]},{"title":"HealthKit阅读理解","slug":"HealthKit阅读理解","date":"2019-09-09T05:35:01.000Z","updated":"2019-09-09T05:44:18.066Z","comments":true,"path":"2019/09/09/HealthKit阅读理解/","link":"","permalink":"https://lisunny.github.io/2019/09/09/HealthKit阅读理解/","excerpt":"HealthKit Data(HealthKit中的数据类型) Characteristic data(固定数据项、不会变) 主要记录不可变数据；例如：生日、血型、性别、肤色等；可以通过HealthKit直接读取，但是不可修改或写入；只能通过Health app修改 Sample data(固定的数据样本)","text":"HealthKit Data(HealthKit中的数据类型) Characteristic data(固定数据项、不会变) 主要记录不可变数据；例如：生日、血型、性别、肤色等；可以通过HealthKit直接读取，但是不可修改或写入；只能通过Health app修改 Sample data(固定的数据样本) 绝大多数的用户健康数据都在特定节点时间内写入对应样本数据；HKSample是所有样本类的父类；HKSample是HKObject的子类 Workout data(健康、锻炼) 健康和锻炼活动数据被存储在HKWorkoutSamples,与一般的sample class略有不同，详见Workout Data Source data 每一个样本存储信息都有一个数据来源，HKSourceRevision类可以保存是什么App或设备写入的样本数据，HKDevice类保存了是什么硬件保存的数据 Delete objects HKDeletedObject实例主要用于临时保存从HealthKit store中删除数据的UUID，同样可以用Delete objects作为一个删除操作的答复。详见HKAnchoredObjectQuery和HKDeletedObject Samples的四种分类 Category samples 数据可以被归类到一个有限的集合中，详见HKCategorySample Quantity samples 所有可以被保存为一个数字的数据，是HealthKit中最为常见的数据类型;例如：身高、体重、步数。详见HKQuantitySample Correlations 复合数据，可能包含一个或多个samples。在iOS8中，HealthKit用correlationgs来表示食物和血压。详见HKCorrelation Workouts 表示例如：跑步、游泳等运动数据，会包含类型、时长、距离和消耗热量等属性。","categories":[{"name":"iOS官方文档阅读理解","slug":"iOS官方文档阅读理解","permalink":"https://lisunny.github.io/categories/iOS官方文档阅读理解/"}],"tags":[]},{"title":"Android待学习知识点","slug":"Android待学习知识点","date":"2019-09-09T05:31:31.000Z","updated":"2019-09-09T05:34:18.508Z","comments":true,"path":"2019/09/09/Android待学习知识点/","link":"","permalink":"https://lisunny.github.io/2019/09/09/Android待学习知识点/","excerpt":"","text":"build.gradle 中的NDK是啥意思？ AndroidManifest 中的标签是干嘛用的？ Java方法的重载 和 重写","categories":[{"name":"待学习知识点","slug":"待学习知识点","permalink":"https://lisunny.github.io/categories/待学习知识点/"}],"tags":[]},{"title":"界面间传值","slug":"界面间传值","date":"2019-09-09T04:02:46.000Z","updated":"2019-09-09T04:04:35.518Z","comments":true,"path":"2019/09/09/界面间传值/","link":"","permalink":"https://lisunny.github.io/2019/09/09/界面间传值/","excerpt":"相邻界面间传值正向传值 intent.putExtra(name,value)方法1234567891011//传值activityIntent intent = new Intent(this,InspectionHomeActivity.class);intent.putExtra(InspectionHomeActivity.MENU_ARR, \"menu\");startActivity(intent);//接收值activityIntent intent = getIntent();if(intent.hasStringExtra(InspectionHomeActivity.MENU_ARR))&#123; intent.getStringExtra(InspectionHomeActivity.MENU_ARR);&#125;","text":"相邻界面间传值正向传值 intent.putExtra(name,value)方法1234567891011//传值activityIntent intent = new Intent(this,InspectionHomeActivity.class);intent.putExtra(InspectionHomeActivity.MENU_ARR, \"menu\");startActivity(intent);//接收值activityIntent intent = getIntent();if(intent.hasStringExtra(InspectionHomeActivity.MENU_ARR))&#123; intent.getStringExtra(InspectionHomeActivity.MENU_ARR);&#125; 反向传值 setResult(ResultCode,intent)方法123456789101112131415161718192021//传值activityIntent intent = new Intent();intent.putExtra(\"result\",result);setResult(resultCode,intent);finish();//接收值activity//跳转到传值activityIntent intent = new Intent();startActivityForResult(intent,nfcBindResultCode);//重写result方法@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data)&#123; super.onActivityResult(requestCode, resultCode, data); if(requestCode == nfcBindResultCode &amp;&amp; resultCode == resultCode)&#123; if(data.hasExtra(\"\"))&#123; data.getExtra(\"\"); &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://lisunny.github.io/categories/Android/"}],"tags":[{"name":"页面间通信","slug":"页面间通信","permalink":"https://lisunny.github.io/tags/页面间通信/"}]},{"title":"Activity的生命周期","slug":"Activity的生命周期","date":"2019-09-09T03:54:33.000Z","updated":"2019-09-09T04:02:16.888Z","comments":true,"path":"2019/09/09/Activity的生命周期/","link":"","permalink":"https://lisunny.github.io/2019/09/09/Activity的生命周期/","excerpt":"Activity生命周期图Activity的几个关键节点 生命周期 Activity的整个生命周期开始于onCreat(),结束于onDestory(),所以Activity的所有初始化工作都在onCreat()方法中完成，在onDestory()方法中销毁 可视的关键节点 Activity可视周期开始于onStart(),结束于onStop(),着这段周期内可以处理所有的关于UI的展示工作，例如：可以在onStart()方法中注册BroadcastReceiver去改变你的UI，在onStop()方法中注销掉这个接收者","text":"Activity生命周期图Activity的几个关键节点 生命周期 Activity的整个生命周期开始于onCreat(),结束于onDestory(),所以Activity的所有初始化工作都在onCreat()方法中完成，在onDestory()方法中销毁 可视的关键节点 Activity可视周期开始于onStart(),结束于onStop(),着这段周期内可以处理所有的关于UI的展示工作，例如：可以在onStart()方法中注册BroadcastReceiver去改变你的UI，在onStop()方法中注销掉这个接收者 Activity在栈顶 由onResume()到onPause()这段周期，activity是在所有的activity的顶部的 整个生命周期的关键方法1234567891011121314151617181920212223public class Activity extends ApplicationContext &#123; //当activity第一次启动时调用 //做一些初始化、布局、响应事件的注册 protected void onCreate(Bundle savedInstanceState); //当activity可见时调用 protected void onStart(); //当activity stop之后再次启动时调用 protected void onRestart(); //当activity 即将可见时调用 此时activity已经在栈顶 protected void onResume(); //当其他activity即将启动时调用 protected void onPause(); //当其他activity在栈顶时调用 protected void onStop(); //activity被销毁 protected void onDestroy(); &#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://lisunny.github.io/categories/Android/"}],"tags":[{"name":"生命周期","slug":"生命周期","permalink":"https://lisunny.github.io/tags/生命周期/"},{"name":"activity","slug":"activity","permalink":"https://lisunny.github.io/tags/activity/"}]},{"title":"RadioGroup相关小知识","slug":"RadioGroup相关小知识","date":"2019-09-09T03:52:34.000Z","updated":"2019-09-09T03:54:08.520Z","comments":true,"path":"2019/09/09/RadioGroup相关小知识/","link":"","permalink":"https://lisunny.github.io/2019/09/09/RadioGroup相关小知识/","excerpt":"setOnCheckedChangeListener在某些时候点击RadioGroup，可能有多次进入该回调方法 在listview中使用RadioGroup,因为刷新的原因，可能会代码设置选中；每次reload都会导致两次调用onCheckedChanged方法； 解决的思路就是屏蔽掉非press的事件","text":"setOnCheckedChangeListener在某些时候点击RadioGroup，可能有多次进入该回调方法 在listview中使用RadioGroup,因为刷新的原因，可能会代码设置选中；每次reload都会导致两次调用onCheckedChanged方法； 解决的思路就是屏蔽掉非press的事件 解决办法，如下： 1234567891011@Overridepublic void onCheckedChanged(RadioGroup group, int checkedId) &#123; //添加如下方法 View viewById = group.findViewById(checkedId); if (!viewById.isPressed())&#123; return; &#125; //自己的逻辑代码&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://lisunny.github.io/categories/Android/"}],"tags":[{"name":"RadioButton","slug":"RadioButton","permalink":"https://lisunny.github.io/tags/RadioButton/"},{"name":"控件","slug":"控件","permalink":"https://lisunny.github.io/tags/控件/"}]},{"title":"自定义AlertDialog","slug":"自定义AlertDialog","date":"2019-09-09T03:49:45.000Z","updated":"2019-09-09T03:52:03.097Z","comments":true,"path":"2019/09/09/自定义AlertDialog/","link":"","permalink":"https://lisunny.github.io/2019/09/09/自定义AlertDialog/","excerpt":"","text":"AlertDialog 继承于Dialog,自定义时主要重写构造方法、onCreat方法、点击事件的处理返回 实现方式 继承于系统AlertDialog 自定义layout文件 内部自定义实现事件处理 步骤 创建SimpleAlertDialog继承于AlertDialog123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134public class SimpleAlertDialog extends AlertDialog implements View.OnClickListener &#123; private TextView title_text_view; private TextView message_text_view; private Button left_action_button; private Button right_action_button; private String mMessage; private String mTitle; private String mLeftActionName; private String mRightActionName; private OnCancelListener mOnCancelListener; private View.OnClickListener mOnClickListener; public SimpleAlertDialog(Context context,String message, String title,String leftActionName, String rightActionName) &#123; super(context); mTitle = title; mMessage = message; mLeftActionName = leftActionName; mRightActionName = rightActionName; &#125; public SimpleAlertDialog(Context context, String message, String title, String leftActionName, String rightActionName, boolean cancelable, OnCancelListener cancelListener, View.OnClickListener clickListener) &#123; super(context, cancelable, cancelListener); /** cancelable 字段为是否可点击它处取消 */ mTitle = title; mMessage = message; mLeftActionName = leftActionName; mRightActionName = rightActionName; mOnCancelListener = cancelListener; mOnClickListener = clickListener; &#125; public SimpleAlertDialog(Context context,String message, String title,String leftActionName, String rightActionName,int themeResId) &#123; super(context, themeResId); mTitle = title; mMessage = message; mLeftActionName = leftActionName; mRightActionName = rightActionName; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.simpler_alert_dialog); title_text_view = (TextView)findViewById(R.id.dialog_title_text_view); message_text_view = (TextView)findViewById(R.id.dialog_message_text_view); left_action_button = (Button)findViewById(R.id.left_action_button); right_action_button = (Button)findViewById(R.id.right_action_button); configerUI(); &#125; private void configerUI()&#123; if (!TextUtils.isEmpty(mTitle))&#123; title_text_view.setText(mTitle); &#125;else &#123; title_text_view.setVisibility(View.GONE); &#125; if (!TextUtils.isEmpty(mMessage))&#123; message_text_view.setText(mMessage); &#125;else &#123; message_text_view.setVisibility(View.GONE); &#125; if (!TextUtils.isEmpty(mLeftActionName))&#123; left_action_button.setText(mLeftActionName); &#125;else &#123; left_action_button.setVisibility(View.GONE); &#125; if (!TextUtils.isEmpty(mRightActionName))&#123; right_action_button.setText(mRightActionName); &#125;else &#123; right_action_button.setVisibility(View.GONE); &#125; left_action_button.setOnClickListener(this); right_action_button.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; if (v.getId() == R.id.left_action_button)&#123; mOnCancelListener.onCancel(this); this.dismiss(); &#125;else if (v.getId() == R.id.right_action_button)&#123; mOnClickListener.onClick(right_action_button); this.dismiss(); &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://lisunny.github.io/categories/Android/"}],"tags":[{"name":"自定义组件","slug":"自定义组件","permalink":"https://lisunny.github.io/tags/自定义组件/"},{"name":"AlertDialog","slug":"AlertDialog","permalink":"https://lisunny.github.io/tags/AlertDialog/"}]},{"title":"BoardcastReceiver","slug":"BoardcastReceiver","date":"2019-09-09T03:42:58.000Z","updated":"2019-09-09T03:48:52.701Z","comments":true,"path":"2019/09/09/BoardcastReceiver/","link":"","permalink":"https://lisunny.github.io/2019/09/09/BoardcastReceiver/","excerpt":"什么是BoardcastReceiver？ 简单来说就是iOS中的NSNotification类，主要用来接收系统、自定义的广播，但是又不同于iOS的消息中心 先进行广播的注册，然后实现接收方法即可 广播的实现 继承BoardcastReceiver类，实现自定的receiver 实现onReceiver方法，来处理接收到的广播信息举个栗子：12345678910111213141516public class NotificationHandleReceiver extends BroadcastReceiver &#123; private NotificationHandleInterface notificationHandleInterface; public NotificationHandleReceiver(NotificationHandleInterface interfaceHandle)&#123; this.notificationHandleInterface = interfaceHandle; &#125; @Override public void onReceive(Context context, Intent intent) &#123; // TODO: This method is called when the BroadcastReceiver is receiving // an Intent broadcast. notificationHandleInterface.receiverNewNotification(); &#125;&#125;","text":"什么是BoardcastReceiver？ 简单来说就是iOS中的NSNotification类，主要用来接收系统、自定义的广播，但是又不同于iOS的消息中心 先进行广播的注册，然后实现接收方法即可 广播的实现 继承BoardcastReceiver类，实现自定的receiver 实现onReceiver方法，来处理接收到的广播信息举个栗子：12345678910111213141516public class NotificationHandleReceiver extends BroadcastReceiver &#123; private NotificationHandleInterface notificationHandleInterface; public NotificationHandleReceiver(NotificationHandleInterface interfaceHandle)&#123; this.notificationHandleInterface = interfaceHandle; &#125; @Override public void onReceive(Context context, Intent intent) &#123; // TODO: This method is called when the BroadcastReceiver is receiving // an Intent broadcast. notificationHandleInterface.receiverNewNotification(); &#125;&#125; 广播的注册广播注册、和销毁是一定要对应处理的 注册12IntentFilter intentFilter = new IntentFilter(TokenExpriseAction);registerReceiver(tokenTimeOutReceiver,intentFilter); 取消注册1unregisterReceiver(tokenTimeOutReceiver); 如果在activity中做广播的注册、取消注册操作时，一定要注意activity的生命周期；一般情况下都是在onResume()方法中注册，onPause()放法中取消注册，关于activity生命周期的相信介绍点这里","categories":[{"name":"Android","slug":"Android","permalink":"https://lisunny.github.io/categories/Android/"}],"tags":[{"name":"Receiver","slug":"Receiver","permalink":"https://lisunny.github.io/tags/Receiver/"},{"name":"四大组件","slug":"四大组件","permalink":"https://lisunny.github.io/tags/四大组件/"}]},{"title":"iMazing","slug":"iMazing","date":"2019-09-09T02:24:28.000Z","updated":"2019-12-06T08:13:48.322Z","comments":true,"path":"2019/09/09/iMazing/","link":"","permalink":"https://lisunny.github.io/2019/09/09/iMazing/","excerpt":"","text":"该工具功能类似iTunes，Mac OS 10.14版本iTunes不在提供App下载及管理功能；iMazing应运而生，对开发者来讲可以用这个工具下载手机内App的IPA安装包，具体流程如下：使用教程传送门","categories":[{"name":"效率工具","slug":"效率工具","permalink":"https://lisunny.github.io/categories/效率工具/"}],"tags":[{"name":"App数据查看工具","slug":"App数据查看工具","permalink":"https://lisunny.github.io/tags/App数据查看工具/"}]},{"title":"Charles","slug":"Charles","date":"2019-09-09T02:24:12.000Z","updated":"2019-09-09T03:36:49.467Z","comments":true,"path":"2019/09/09/Charles/","link":"","permalink":"https://lisunny.github.io/2019/09/09/Charles/","excerpt":"","text":"该工具主要做网络调试、网络抓包使用注册激活码：Name: https://zhile.ioLicense Key: 48891cf209c6d32bf4⚠️下载地址传送门⚠️","categories":[{"name":"效率工具","slug":"效率工具","permalink":"https://lisunny.github.io/categories/效率工具/"}],"tags":[{"name":"网络抓包","slug":"网络抓包","permalink":"https://lisunny.github.io/tags/网络抓包/"}]},{"title":"OmniGraffle","slug":"OmniGraffle","date":"2019-09-09T02:23:54.000Z","updated":"2019-09-09T02:40:12.676Z","comments":true,"path":"2019/09/09/OmniGraffle/","link":"","permalink":"https://lisunny.github.io/2019/09/09/OmniGraffle/","excerpt":"","text":"该工作主要用户画图，流程图最佳！注册码 账号：Appked 密码：MFWG-GHEB-HYTW-CGHT-CSXU-QCNC-SXU下载地址","categories":[{"name":"效率工具","slug":"效率工具","permalink":"https://lisunny.github.io/categories/效率工具/"}],"tags":[{"name":"流程图绘制工具","slug":"流程图绘制工具","permalink":"https://lisunny.github.io/tags/流程图绘制工具/"}]},{"title":"iOS关于根视图的切换问题总结","slug":"iOS关于根视图的切换问题总结","date":"2019-09-09T02:08:10.000Z","updated":"2019-09-09T03:38:10.481Z","comments":true,"path":"2019/09/09/iOS关于根视图的切换问题总结/","link":"","permalink":"https://lisunny.github.io/2019/09/09/iOS关于根视图的切换问题总结/","excerpt":"在项目中有时某些功能是需要登录才能使用的，登录后一个跟视图，登录前一个跟视图；那就需要一个根据登录状态来修改跟视图的功能；修改跟视图也就是两行代码，并不难，难点主要在于页面跳转的同事修改跟视图时的代码执行顺序；修改根视图代码12UINavigationController * rootNav = [[UINavigationController alloc] initWithRootViewController:[[MainViewController alloc] init]];[UIApplication sharedApplication].keyWindow.rootViewController = rootNav;","text":"在项目中有时某些功能是需要登录才能使用的，登录后一个跟视图，登录前一个跟视图；那就需要一个根据登录状态来修改跟视图的功能；修改跟视图也就是两行代码，并不难，难点主要在于页面跳转的同事修改跟视图时的代码执行顺序；修改根视图代码12UINavigationController * rootNav = [[UINavigationController alloc] initWithRootViewController:[[MainViewController alloc] init]];[UIApplication sharedApplication].keyWindow.rootViewController = rootNav; 页面跳转代码 12[self.navigationController pushViewController:[[MainViewController alloc] init] animated:YES]; 在小尼平安项目中遇到一个诡异的问题，同样的代码执行顺序，在controller中执行总是会崩溃；如下：网络请求类中： 123UINavigationController * rootNav = [[UINavigationController alloc] initWithRootViewController:login];[UIApplication sharedApplication].keyWindow.rootViewController = rootNav;[currentVC.navigationController popToRootViewControllerAnimated:false]; controller中用同样的写法就会崩溃thread1:exc_breakpoint，如果改成先跳转再设置跟视图就不会崩溃，具体的原因展示还没有搞清楚","categories":[{"name":"iOS","slug":"iOS","permalink":"https://lisunny.github.io/categories/iOS/"}],"tags":[{"name":"根视图管理","slug":"根视图管理","permalink":"https://lisunny.github.io/tags/根视图管理/"}]},{"title":"关于焦点获取问题的一些知识点","slug":"关于焦点获取问题的一些知识点","date":"2019-09-06T08:47:09.000Z","updated":"2019-09-09T03:48:33.164Z","comments":true,"path":"2019/09/06/关于焦点获取问题的一些知识点/","link":"","permalink":"https://lisunny.github.io/2019/09/06/关于焦点获取问题的一些知识点/","excerpt":"","text":"XML的一些属性descendantFocusablility主要用来定义父视图和子视图在获取焦点时的先后顺序逻辑，主要应用于在listview 或 GridView中嵌套了button，导致itemClick时间无法响应的问题，详见下表： 参数 值 描述 afterDescendants 1 父视图只有在子视图不需要焦点时，才会获取焦点 beforeDescendants 0 父视图优先于子视图获取焦点 blocksDescendants 2 父视图将阻止其后代获得焦点。","categories":[{"name":"Android","slug":"Android","permalink":"https://lisunny.github.io/categories/Android/"}],"tags":[{"name":"焦点","slug":"焦点","permalink":"https://lisunny.github.io/tags/焦点/"},{"name":"EditText","slug":"EditText","permalink":"https://lisunny.github.io/tags/EditText/"}]},{"title":"Canvas开发中遇到的几点问题","slug":"Canvas开发中遇到的几点问题","date":"2019-09-06T08:18:36.000Z","updated":"2019-09-09T03:49:07.085Z","comments":true,"path":"2019/09/06/Canvas开发中遇到的几点问题/","link":"","permalink":"https://lisunny.github.io/2019/09/06/Canvas开发中遇到的几点问题/","excerpt":"Canvas字面意思为画布，Canvas为Android中绘制开发不可获取的类；当然在自定义绘制过程中，紧紧使用Canvas类是不够的，还需要它的好基友： Bitmap 指定绘画路径、曲线、文字或图片(Rect、Path、Text、Bitmap等) 画笔（Paint）下面我们先展开来说一下各个基友该如何使用及注意事项；Canvas画布，在自定义绘制中使用频率最高的类，提供了非常非常多的图像绘制API（具体绘制API可取开发者平台查看）;这里主要做一下Canvas几个常用且易错函数坐下具体分析：","text":"Canvas字面意思为画布，Canvas为Android中绘制开发不可获取的类；当然在自定义绘制过程中，紧紧使用Canvas类是不够的，还需要它的好基友： Bitmap 指定绘画路径、曲线、文字或图片(Rect、Path、Text、Bitmap等) 画笔（Paint）下面我们先展开来说一下各个基友该如何使用及注意事项；Canvas画布，在自定义绘制中使用频率最高的类，提供了非常非常多的图像绘制API（具体绘制API可取开发者平台查看）;这里主要做一下Canvas几个常用且易错函数坐下具体分析： 恢复画布状态1public void restore () 该方法在save()方法调用之后调用，用于删除自上次保存调用以来对矩阵/剪辑状态的所有修改在下次操作Canvas时，提供一个全新状态的Canvas这里需要注意的是： 恢复到上传save()的状态 restore()的调用次数应少于save()调用次数；当你在使用了Canvas的Rotate()等方法后，要调用该方法，以防止画布旋转对后续绘制的影响 画布旋转这个方法一般用于绘制仪表刻度、指针等需要旋转绘制的内容 123456/** 旋转画布到指定角度（0度 开始旋转）0度在最右位置 */public void rotate (float degrees)/** 已传入点为中心旋转画布到指定角度（0度 开始旋转）0度在最右位置 */public final void rotate (float degrees, float px, float py) 保存画布保存当前的画布操作及属性 1public int save () 缩放 123456public final void scale (float sx, float sy, float px, float py)public void scale (float sx, float sy) 平移 12public void translate (float dx, float dy) Bitmap指定绘画路径、曲线、文字或图片(Rect、Path、Text、Bitmap等) Rect 在绘制曲线、圆、矩形时，可以通过指定绘制区域Rect的方式，简化绘制参数的传入；例如：在绘制弧形曲线时,Canvas类提供了如下两种方法，在你想画不是特别复杂的圆弧时，我想第二种方法应该是最简单、易用得啦！ 12345678910111213public void drawArc (float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint)public void drawArc (RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint) 第二种方法中的RectF参数即为控制绘画曲线区域的数据类型； 画笔（Paint） 你好","categories":[{"name":"Android","slug":"Android","permalink":"https://lisunny.github.io/categories/Android/"}],"tags":[{"name":"Canvas","slug":"Canvas","permalink":"https://lisunny.github.io/tags/Canvas/"},{"name":"自定义绘制","slug":"自定义绘制","permalink":"https://lisunny.github.io/tags/自定义绘制/"}]},{"title":"1k卡的开发实践","slug":"1k卡的开发实践","date":"2019-09-06T07:56:32.000Z","updated":"2019-09-10T07:16:24.917Z","comments":true,"path":"2019/09/06/1k卡的开发实践/","link":"","permalink":"https://lisunny.github.io/2019/09/06/1k卡的开发实践/","excerpt":"最近工作需要学习了下AndroidNFC开发，主要是M1卡信息读取；简单的卡读取当然是没有任何难度，百度一堆代码，拿来就能用；本次的难点主要在后端给定keyA，然后通过keyA读取指定扇区的数据；功能不难，但由于不了解M1卡同时没有深入理解NDEF数据格式，导致在开发过程中浪费了不少时间，所以记录下，以备遗忘；","text":"最近工作需要学习了下AndroidNFC开发，主要是M1卡信息读取；简单的卡读取当然是没有任何难度，百度一堆代码，拿来就能用；本次的难点主要在后端给定keyA，然后通过keyA读取指定扇区的数据；功能不难，但由于不了解M1卡同时没有深入理解NDEF数据格式，导致在开发过程中浪费了不少时间，所以记录下，以备遗忘； 什么是NFC? NFC(Near Field Communication)即近距离无线通讯技术。2003年由飞利浦公司和索尼公司共同开发，它是一种非接触式识别和互联技术。 NFC卡都有哪些种类？关于Mifare 1k卡你需要了解的相关信息M1卡的内存结构 M1卡共16个扇区 每个扇区有4个数据块 每个扇区的最后一个数据块并不保存数据 0扇区的0数据块比较特殊，一般出厂写入且不可修改。（特殊的可无限擦写的UID CUID卡除外）","categories":[{"name":"Android","slug":"Android","permalink":"https://lisunny.github.io/categories/Android/"}],"tags":[{"name":"NFC","slug":"NFC","permalink":"https://lisunny.github.io/tags/NFC/"},{"name":"M1卡","slug":"M1卡","permalink":"https://lisunny.github.io/tags/M1卡/"}]}]}