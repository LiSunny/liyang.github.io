{"meta":{"title":"LiYang","subtitle":null,"description":null,"author":"LiYang","url":"https://lisunny.github.io","root":"/liyang.github.io/"},"pages":[{"title":"1k卡的开发实践","date":"2019-09-06T07:56:32.000Z","updated":"2019-09-09T03:28:27.867Z","comments":true,"path":"Android/1k卡的开发实践.html","permalink":"https://lisunny.github.io/Android/1k卡的开发实践.html","excerpt":"","text":"Android NFC M1卡最近工作需要学习了下AndroidNFC开发，主要是M1卡信息读取；简单的卡读取当然是没有任何难度，百度一堆代码，拿来就能用；本次的难点主要在后端给定keyA，然后通过keyA读取指定扇区的数据；功能不难，但由于不了解M1卡同时没有深入理解NDEF数据格式，导致在开发过程中浪费了不少时间，所以记录下，以备遗忘； 什么是NFC? NFC(Near Field Communication)即近距离无线通讯技术。2003年由飞利浦公司和索尼公司共同开发，它是一种非接触式识别和互联技术。 NFC卡都有哪些种类？关于Mifare 1k卡你需要了解的相关信息M1卡的内存结构 M1卡共16个扇区 每个扇区有4个数据块 每个扇区的最后一个数据块并不保存数据 0扇区的0数据块比较特殊，一般出厂写入且不可修改。（特殊的可无限擦写的UID CUID卡除外）"},{"title":"Android","date":"2019-09-09T03:02:02.000Z","updated":"2019-09-09T03:02:02.634Z","comments":true,"path":"Android/index.html","permalink":"https://lisunny.github.io/Android/index.html","excerpt":"","text":""},{"title":"Search","date":"2019-09-09T07:29:26.000Z","updated":"2019-09-09T07:29:34.901Z","comments":true,"path":"Search/index.html","permalink":"https://lisunny.github.io/Search/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-09-09T08:09:28.000Z","updated":"2019-09-09T08:09:44.690Z","comments":true,"path":"categories/index.html","permalink":"https://lisunny.github.io/categories/index.html","excerpt":"","text":""},{"title":"iOS关于根视图的切换问题总结","date":"2019-09-09T02:08:10.000Z","updated":"2019-09-09T03:38:10.481Z","comments":true,"path":"iOS/iOS关于根视图的切换问题总结.html","permalink":"https://lisunny.github.io/iOS/iOS关于根视图的切换问题总结.html","excerpt":"","text":"在项目中有时某些功能是需要登录才能使用的，登录后一个跟视图，登录前一个跟视图；那就需要一个根据登录状态来修改跟视图的功能；修改跟视图也就是两行代码，并不难，难点主要在于页面跳转的同事修改跟视图时的代码执行顺序；修改根视图代码 12UINavigationController * rootNav = [[UINavigationController alloc] initWithRootViewController:[[MainViewController alloc] init]];[UIApplication sharedApplication].keyWindow.rootViewController = rootNav; 页面跳转代码 12[self.navigationController pushViewController:[[MainViewController alloc] init] animated:YES]; 在小尼平安项目中遇到一个诡异的问题，同样的代码执行顺序，在controller中执行总是会崩溃；如下：网络请求类中： 123UINavigationController * rootNav = [[UINavigationController alloc] initWithRootViewController:login];[UIApplication sharedApplication].keyWindow.rootViewController = rootNav;[currentVC.navigationController popToRootViewControllerAnimated:false]; controller中用同样的写法就会崩溃thread1:exc_breakpoint，如果改成先跳转再设置跟视图就不会崩溃，具体的原因展示还没有搞清楚"},{"title":"iOS","date":"2019-09-09T03:01:42.000Z","updated":"2019-09-09T07:48:17.495Z","comments":true,"path":"iOS/index.html","permalink":"https://lisunny.github.io/iOS/index.html","excerpt":"","text":""},{"title":"/效率工具","date":"2019-09-09T03:24:30.000Z","updated":"2019-09-09T03:24:30.085Z","comments":true,"path":"效率工具/index.html","permalink":"https://lisunny.github.io/效率工具/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-09-09T07:26:27.000Z","updated":"2019-09-09T08:08:35.360Z","comments":true,"path":"tags/index.html","permalink":"https://lisunny.github.io/tags/index.html","excerpt":"","text":""},{"title":"iOS关于根视图的切换问题总结","date":"2019-09-09T02:08:10.000Z","updated":"2019-09-09T03:38:10.481Z","comments":true,"path":"iOS/index/iOS关于根视图的切换问题总结.html","permalink":"https://lisunny.github.io/iOS/index/iOS关于根视图的切换问题总结.html","excerpt":"","text":"在项目中有时某些功能是需要登录才能使用的，登录后一个跟视图，登录前一个跟视图；那就需要一个根据登录状态来修改跟视图的功能；修改跟视图也就是两行代码，并不难，难点主要在于页面跳转的同事修改跟视图时的代码执行顺序；修改根视图代码 12UINavigationController * rootNav = [[UINavigationController alloc] initWithRootViewController:[[MainViewController alloc] init]];[UIApplication sharedApplication].keyWindow.rootViewController = rootNav; 页面跳转代码 12[self.navigationController pushViewController:[[MainViewController alloc] init] animated:YES]; 在小尼平安项目中遇到一个诡异的问题，同样的代码执行顺序，在controller中执行总是会崩溃；如下：网络请求类中： 123UINavigationController * rootNav = [[UINavigationController alloc] initWithRootViewController:login];[UIApplication sharedApplication].keyWindow.rootViewController = rootNav;[currentVC.navigationController popToRootViewControllerAnimated:false]; controller中用同样的写法就会崩溃thread1:exc_breakpoint，如果改成先跳转再设置跟视图就不会崩溃，具体的原因展示还没有搞清楚"}],"posts":[{"title":"关于Git版本控制的一些想法","slug":"关于Git版本控制的一些想法","date":"2019-09-09T05:48:30.000Z","updated":"2019-09-09T05:49:56.344Z","comments":true,"path":"2019/09/09/关于Git版本控制的一些想法/","link":"","permalink":"https://lisunny.github.io/2019/09/09/关于Git版本控制的一些想法/","excerpt":"","text":"一个项目到底要有多少个分支才合适？ 一般情况下独立开发的项目好多人都喜欢用一条分支，简单、粗暴没有那么多的麻烦。但随着一个人负责的项目越来越多、迭代开发越来越多，临时打包的情况时常发生。你想啊！正在写新功能，突然就然你打个包，这酸爽简直不敢想象！所以好的分支管理还是非常有必要的。 现阶段我个人觉得一个项目至少要有2条分支 Master分支（主要用来保存经过测试，功能完整，安装即可使用的） Dev分支（主要用来保存开发阶段代码） 各个分支要怎样管理才好？ 开发过程一定是在Dev分支，测试无误，提交至Master分支 Master分支不做修改操作，只是用来保存功能完整的代码 Master分支要做好tag管理，既每测试完成一个版本要做好区分和备份","categories":[{"name":"工作流的思考","slug":"工作流的思考","permalink":"https://lisunny.github.io/categories/工作流的思考/"}],"tags":[]},{"title":"HealthKit阅读理解","slug":"HealthKit阅读理解","date":"2019-09-09T05:35:01.000Z","updated":"2019-09-09T05:44:18.066Z","comments":true,"path":"2019/09/09/HealthKit阅读理解/","link":"","permalink":"https://lisunny.github.io/2019/09/09/HealthKit阅读理解/","excerpt":"","text":"HealthKit Data(HealthKit中的数据类型) Characteristic data(固定数据项、不会变) 主要记录不可变数据；例如：生日、血型、性别、肤色等；可以通过HealthKit直接读取，但是不可修改或写入；只能通过Health app修改 Sample data(固定的数据样本) 绝大多数的用户健康数据都在特定节点时间内写入对应样本数据；HKSample是所有样本类的父类；HKSample是HKObject的子类 Workout data(健康、锻炼) 健康和锻炼活动数据被存储在HKWorkoutSamples,与一般的sample class略有不同，详见Workout Data Source data 每一个样本存储信息都有一个数据来源，HKSourceRevision类可以保存是什么App或设备写入的样本数据，HKDevice类保存了是什么硬件保存的数据 Delete objects HKDeletedObject实例主要用于临时保存从HealthKit store中删除数据的UUID，同样可以用Delete objects作为一个删除操作的答复。详见HKAnchoredObjectQuery和HKDeletedObject Samples的四种分类 Category samples 数据可以被归类到一个有限的集合中，详见HKCategorySample Quantity samples 所有可以被保存为一个数字的数据，是HealthKit中最为常见的数据类型;例如：身高、体重、步数。详见HKQuantitySample Correlations 复合数据，可能包含一个或多个samples。在iOS8中，HealthKit用correlationgs来表示食物和血压。详见HKCorrelation Workouts 表示例如：跑步、游泳等运动数据，会包含类型、时长、距离和消耗热量等属性。","categories":[{"name":"iOS官方文档阅读理解","slug":"iOS官方文档阅读理解","permalink":"https://lisunny.github.io/categories/iOS官方文档阅读理解/"}],"tags":[]},{"title":"Android待学习知识点","slug":"Android待学习知识点","date":"2019-09-09T05:31:31.000Z","updated":"2019-09-09T05:34:18.508Z","comments":true,"path":"2019/09/09/Android待学习知识点/","link":"","permalink":"https://lisunny.github.io/2019/09/09/Android待学习知识点/","excerpt":"","text":"build.gradle 中的NDK是啥意思？ AndroidManifest 中的标签是干嘛用的？ Java方法的重载 和 重写","categories":[{"name":"待学习知识点","slug":"待学习知识点","permalink":"https://lisunny.github.io/categories/待学习知识点/"}],"tags":[]},{"title":"界面间传值","slug":"界面间传值","date":"2019-09-09T04:02:46.000Z","updated":"2019-09-09T04:04:35.518Z","comments":true,"path":"2019/09/09/界面间传值/","link":"","permalink":"https://lisunny.github.io/2019/09/09/界面间传值/","excerpt":"","text":"相邻界面间传值正向传值 intent.putExtra(name,value)方法1234567891011//传值activityIntent intent = new Intent(this,InspectionHomeActivity.class);intent.putExtra(InspectionHomeActivity.MENU_ARR, \"menu\");startActivity(intent);//接收值activityIntent intent = getIntent();if(intent.hasStringExtra(InspectionHomeActivity.MENU_ARR))&#123; intent.getStringExtra(InspectionHomeActivity.MENU_ARR);&#125; 反向传值 setResult(ResultCode,intent)方法123456789101112131415161718192021//传值activityIntent intent = new Intent();intent.putExtra(\"result\",result);setResult(resultCode,intent);finish();//接收值activity//跳转到传值activityIntent intent = new Intent();startActivityForResult(intent,nfcBindResultCode);//重写result方法@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data)&#123; super.onActivityResult(requestCode, resultCode, data); if(requestCode == nfcBindResultCode &amp;&amp; resultCode == resultCode)&#123; if(data.hasExtra(\"\"))&#123; data.getExtra(\"\"); &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://lisunny.github.io/categories/Android/"}],"tags":[{"name":"页面间通信","slug":"页面间通信","permalink":"https://lisunny.github.io/tags/页面间通信/"}]},{"title":"Activity的生命周期","slug":"Activity的生命周期","date":"2019-09-09T03:54:33.000Z","updated":"2019-09-09T04:02:16.888Z","comments":true,"path":"2019/09/09/Activity的生命周期/","link":"","permalink":"https://lisunny.github.io/2019/09/09/Activity的生命周期/","excerpt":"","text":"Activity生命周期图 Activity的几个关键节点 生命周期 Activity的整个生命周期开始于onCreat(),结束于onDestory(),所以Activity的所有初始化工作都在onCreat()方法中完成，在onDestory()方法中销毁 可视的关键节点 Activity可视周期开始于onStart(),结束于onStop(),着这段周期内可以处理所有的关于UI的展示工作，例如：可以在onStart()方法中注册BroadcastReceiver去改变你的UI，在onStop()方法中注销掉这个接收者 Activity在栈顶 由onResume()到onPause()这段周期，activity是在所有的activity的顶部的 整个生命周期的关键方法1234567891011121314151617181920212223public class Activity extends ApplicationContext &#123; //当activity第一次启动时调用 //做一些初始化、布局、响应事件的注册 protected void onCreate(Bundle savedInstanceState); //当activity可见时调用 protected void onStart(); //当activity stop之后再次启动时调用 protected void onRestart(); //当activity 即将可见时调用 此时activity已经在栈顶 protected void onResume(); //当其他activity即将启动时调用 protected void onPause(); //当其他activity在栈顶时调用 protected void onStop(); //activity被销毁 protected void onDestroy(); &#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://lisunny.github.io/categories/Android/"}],"tags":[{"name":"生命周期","slug":"生命周期","permalink":"https://lisunny.github.io/tags/生命周期/"},{"name":"activity","slug":"activity","permalink":"https://lisunny.github.io/tags/activity/"}]},{"title":"RadioGroup相关小知识","slug":"RadioGroup相关小知识","date":"2019-09-09T03:52:34.000Z","updated":"2019-09-09T03:54:08.520Z","comments":true,"path":"2019/09/09/RadioGroup相关小知识/","link":"","permalink":"https://lisunny.github.io/2019/09/09/RadioGroup相关小知识/","excerpt":"","text":"setOnCheckedChangeListener在某些时候点击RadioGroup，可能有多次进入该回调方法 在listview中使用RadioGroup,因为刷新的原因，可能会代码设置选中；每次reload都会导致两次调用onCheckedChanged方法； 解决的思路就是屏蔽掉非press的事件 解决办法，如下： 1234567891011@Overridepublic void onCheckedChanged(RadioGroup group, int checkedId) &#123; //添加如下方法 View viewById = group.findViewById(checkedId); if (!viewById.isPressed())&#123; return; &#125; //自己的逻辑代码&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://lisunny.github.io/categories/Android/"}],"tags":[{"name":"RadioButton","slug":"RadioButton","permalink":"https://lisunny.github.io/tags/RadioButton/"},{"name":"控件","slug":"控件","permalink":"https://lisunny.github.io/tags/控件/"}]},{"title":"自定义AlertDialog","slug":"自定义AlertDialog","date":"2019-09-09T03:49:45.000Z","updated":"2019-09-09T03:52:03.097Z","comments":true,"path":"2019/09/09/自定义AlertDialog/","link":"","permalink":"https://lisunny.github.io/2019/09/09/自定义AlertDialog/","excerpt":"","text":"AlertDialog 继承于Dialog,自定义时主要重写构造方法、onCreat方法、点击事件的处理返回 实现方式 继承于系统AlertDialog 自定义layout文件 内部自定义实现事件处理 步骤 创建SimpleAlertDialog继承于AlertDialog123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134public class SimpleAlertDialog extends AlertDialog implements View.OnClickListener &#123; private TextView title_text_view; private TextView message_text_view; private Button left_action_button; private Button right_action_button; private String mMessage; private String mTitle; private String mLeftActionName; private String mRightActionName; private OnCancelListener mOnCancelListener; private View.OnClickListener mOnClickListener; public SimpleAlertDialog(Context context,String message, String title,String leftActionName, String rightActionName) &#123; super(context); mTitle = title; mMessage = message; mLeftActionName = leftActionName; mRightActionName = rightActionName; &#125; public SimpleAlertDialog(Context context, String message, String title, String leftActionName, String rightActionName, boolean cancelable, OnCancelListener cancelListener, View.OnClickListener clickListener) &#123; super(context, cancelable, cancelListener); /** cancelable 字段为是否可点击它处取消 */ mTitle = title; mMessage = message; mLeftActionName = leftActionName; mRightActionName = rightActionName; mOnCancelListener = cancelListener; mOnClickListener = clickListener; &#125; public SimpleAlertDialog(Context context,String message, String title,String leftActionName, String rightActionName,int themeResId) &#123; super(context, themeResId); mTitle = title; mMessage = message; mLeftActionName = leftActionName; mRightActionName = rightActionName; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.simpler_alert_dialog); title_text_view = (TextView)findViewById(R.id.dialog_title_text_view); message_text_view = (TextView)findViewById(R.id.dialog_message_text_view); left_action_button = (Button)findViewById(R.id.left_action_button); right_action_button = (Button)findViewById(R.id.right_action_button); configerUI(); &#125; private void configerUI()&#123; if (!TextUtils.isEmpty(mTitle))&#123; title_text_view.setText(mTitle); &#125;else &#123; title_text_view.setVisibility(View.GONE); &#125; if (!TextUtils.isEmpty(mMessage))&#123; message_text_view.setText(mMessage); &#125;else &#123; message_text_view.setVisibility(View.GONE); &#125; if (!TextUtils.isEmpty(mLeftActionName))&#123; left_action_button.setText(mLeftActionName); &#125;else &#123; left_action_button.setVisibility(View.GONE); &#125; if (!TextUtils.isEmpty(mRightActionName))&#123; right_action_button.setText(mRightActionName); &#125;else &#123; right_action_button.setVisibility(View.GONE); &#125; left_action_button.setOnClickListener(this); right_action_button.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; if (v.getId() == R.id.left_action_button)&#123; mOnCancelListener.onCancel(this); this.dismiss(); &#125;else if (v.getId() == R.id.right_action_button)&#123; mOnClickListener.onClick(right_action_button); this.dismiss(); &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://lisunny.github.io/categories/Android/"}],"tags":[{"name":"自定义组件","slug":"自定义组件","permalink":"https://lisunny.github.io/tags/自定义组件/"},{"name":"AlertDialog","slug":"AlertDialog","permalink":"https://lisunny.github.io/tags/AlertDialog/"}]},{"title":"BoardcastReceiver","slug":"BoardcastReceiver","date":"2019-09-09T03:42:58.000Z","updated":"2019-09-09T03:48:52.701Z","comments":true,"path":"2019/09/09/BoardcastReceiver/","link":"","permalink":"https://lisunny.github.io/2019/09/09/BoardcastReceiver/","excerpt":"","text":"什么是BoardcastReceiver？ 简单来说就是iOS中的NSNotification类，主要用来接收系统、自定义的广播，但是又不同于iOS的消息中心 先进行广播的注册，然后实现接收方法即可 广播的实现 继承BoardcastReceiver类，实现自定的receiver 实现onReceiver方法，来处理接收到的广播信息举个栗子：12345678910111213141516public class NotificationHandleReceiver extends BroadcastReceiver &#123; private NotificationHandleInterface notificationHandleInterface; public NotificationHandleReceiver(NotificationHandleInterface interfaceHandle)&#123; this.notificationHandleInterface = interfaceHandle; &#125; @Override public void onReceive(Context context, Intent intent) &#123; // TODO: This method is called when the BroadcastReceiver is receiving // an Intent broadcast. notificationHandleInterface.receiverNewNotification(); &#125;&#125; 广播的注册广播注册、和销毁是一定要对应处理的 注册12IntentFilter intentFilter = new IntentFilter(TokenExpriseAction);registerReceiver(tokenTimeOutReceiver,intentFilter); 取消注册1unregisterReceiver(tokenTimeOutReceiver); 如果在activity中做广播的注册、取消注册操作时，一定要注意activity的生命周期；一般情况下都是在onResume()方法中注册，onPause()放法中取消注册，关于activity生命周期的相信介绍点这里","categories":[{"name":"Android","slug":"Android","permalink":"https://lisunny.github.io/categories/Android/"}],"tags":[{"name":"Receiver","slug":"Receiver","permalink":"https://lisunny.github.io/tags/Receiver/"},{"name":"四大组件","slug":"四大组件","permalink":"https://lisunny.github.io/tags/四大组件/"}]},{"title":"iMazing","slug":"iMazing","date":"2019-09-09T02:24:28.000Z","updated":"2019-09-09T03:37:26.907Z","comments":true,"path":"2019/09/09/iMazing/","link":"","permalink":"https://lisunny.github.io/2019/09/09/iMazing/","excerpt":"","text":"该工具功能类似iTunes，Mac OS 10.14版本iTunes不在提供App下载及管理功能；iMazing应运而生，对开发者来讲可以用这个工具下载手机内App的IPA安装包，具体流程如下：使用教程传送门","categories":[{"name":"效率工具","slug":"效率工具","permalink":"https://lisunny.github.io/categories/效率工具/"}],"tags":[{"name":"App数据查看工具","slug":"App数据查看工具","permalink":"https://lisunny.github.io/tags/App数据查看工具/"}]},{"title":"Charles","slug":"Charles","date":"2019-09-09T02:24:12.000Z","updated":"2019-09-09T03:36:49.467Z","comments":true,"path":"2019/09/09/Charles/","link":"","permalink":"https://lisunny.github.io/2019/09/09/Charles/","excerpt":"","text":"该工具主要做网络调试、网络抓包使用注册激活码：Name: https://zhile.ioLicense Key: 48891cf209c6d32bf4⚠️下载地址传送门⚠️","categories":[{"name":"效率工具","slug":"效率工具","permalink":"https://lisunny.github.io/categories/效率工具/"}],"tags":[{"name":"网络抓包","slug":"网络抓包","permalink":"https://lisunny.github.io/tags/网络抓包/"}]},{"title":"OmniGraffle","slug":"OmniGraffle","date":"2019-09-09T02:23:54.000Z","updated":"2019-09-09T02:40:12.676Z","comments":true,"path":"2019/09/09/OmniGraffle/","link":"","permalink":"https://lisunny.github.io/2019/09/09/OmniGraffle/","excerpt":"","text":"该工作主要用户画图，流程图最佳！注册码 账号：Appked 密码：MFWG-GHEB-HYTW-CGHT-CSXU-QCNC-SXU下载地址","categories":[{"name":"效率工具","slug":"效率工具","permalink":"https://lisunny.github.io/categories/效率工具/"}],"tags":[{"name":"流程图绘制工具","slug":"流程图绘制工具","permalink":"https://lisunny.github.io/tags/流程图绘制工具/"}]},{"title":"iOS关于根视图的切换问题总结","slug":"iOS关于根视图的切换问题总结","date":"2019-09-09T02:08:10.000Z","updated":"2019-09-09T03:38:10.481Z","comments":true,"path":"2019/09/09/iOS关于根视图的切换问题总结/","link":"","permalink":"https://lisunny.github.io/2019/09/09/iOS关于根视图的切换问题总结/","excerpt":"","text":"在项目中有时某些功能是需要登录才能使用的，登录后一个跟视图，登录前一个跟视图；那就需要一个根据登录状态来修改跟视图的功能；修改跟视图也就是两行代码，并不难，难点主要在于页面跳转的同事修改跟视图时的代码执行顺序；修改根视图代码 12UINavigationController * rootNav = [[UINavigationController alloc] initWithRootViewController:[[MainViewController alloc] init]];[UIApplication sharedApplication].keyWindow.rootViewController = rootNav; 页面跳转代码 12[self.navigationController pushViewController:[[MainViewController alloc] init] animated:YES]; 在小尼平安项目中遇到一个诡异的问题，同样的代码执行顺序，在controller中执行总是会崩溃；如下：网络请求类中： 123UINavigationController * rootNav = [[UINavigationController alloc] initWithRootViewController:login];[UIApplication sharedApplication].keyWindow.rootViewController = rootNav;[currentVC.navigationController popToRootViewControllerAnimated:false]; controller中用同样的写法就会崩溃thread1:exc_breakpoint，如果改成先跳转再设置跟视图就不会崩溃，具体的原因展示还没有搞清楚","categories":[{"name":"iOS","slug":"iOS","permalink":"https://lisunny.github.io/categories/iOS/"}],"tags":[{"name":"根视图管理","slug":"根视图管理","permalink":"https://lisunny.github.io/tags/根视图管理/"}]},{"title":"Android开发keystore","slug":"Android开发keystore","date":"2019-09-06T08:58:35.000Z","updated":"2019-09-09T03:48:43.051Z","comments":true,"path":"2019/09/06/Android开发keystore/","link":"","permalink":"https://lisunny.github.io/2019/09/06/Android开发keystore/","excerpt":"","text":"Android相关App打包keystore都在项目根目录中相关别名、密码如下： key 密码 keyPassword NEAT123 storePassword NEAT123","categories":[{"name":"Android","slug":"Android","permalink":"https://lisunny.github.io/categories/Android/"}],"tags":[{"name":"项目配置","slug":"项目配置","permalink":"https://lisunny.github.io/tags/项目配置/"}]},{"title":"关于焦点获取问题的一些知识点","slug":"关于焦点获取问题的一些知识点","date":"2019-09-06T08:47:09.000Z","updated":"2019-09-09T03:48:33.164Z","comments":true,"path":"2019/09/06/关于焦点获取问题的一些知识点/","link":"","permalink":"https://lisunny.github.io/2019/09/06/关于焦点获取问题的一些知识点/","excerpt":"","text":"XML的一些属性descendantFocusablility主要用来定义父视图和子视图在获取焦点时的先后顺序逻辑，主要应用于在listview 或 GridView中嵌套了button，导致itemClick时间无法响应的问题，详见下表： 参数 值 描述 afterDescendants 1 父视图只有在子视图不需要焦点时，才会获取焦点 beforeDescendants 0 父视图优先于子视图获取焦点 blocksDescendants 2 父视图将阻止其后代获得焦点。","categories":[{"name":"Android","slug":"Android","permalink":"https://lisunny.github.io/categories/Android/"}],"tags":[{"name":"焦点","slug":"焦点","permalink":"https://lisunny.github.io/tags/焦点/"},{"name":"EditText","slug":"EditText","permalink":"https://lisunny.github.io/tags/EditText/"}]},{"title":"Canvas开发中遇到的几点问题","slug":"Canvas开发中遇到的几点问题","date":"2019-09-06T08:18:36.000Z","updated":"2019-09-09T03:49:07.085Z","comments":true,"path":"2019/09/06/Canvas开发中遇到的几点问题/","link":"","permalink":"https://lisunny.github.io/2019/09/06/Canvas开发中遇到的几点问题/","excerpt":"","text":"Canvas字面意思为画布，Canvas为Android中绘制开发不可获取的类；当然在自定义绘制过程中，紧紧使用Canvas类是不够的，还需要它的好基友： Bitmap 指定绘画路径、曲线、文字或图片(Rect、Path、Text、Bitmap等) 画笔（Paint）下面我们先展开来说一下各个基友该如何使用及注意事项；Canvas画布，在自定义绘制中使用频率最高的类，提供了非常非常多的图像绘制API（具体绘制API可取开发者平台查看）;这里主要做一下Canvas几个常用且易错函数坐下具体分析： 恢复画布状态1public void restore () 该方法在save()方法调用之后调用，用于删除自上次保存调用以来对矩阵/剪辑状态的所有修改在下次操作Canvas时，提供一个全新状态的Canvas这里需要注意的是： 恢复到上传save()的状态 restore()的调用次数应少于save()调用次数；当你在使用了Canvas的Rotate()等方法后，要调用该方法，以防止画布旋转对后续绘制的影响 画布旋转这个方法一般用于绘制仪表刻度、指针等需要旋转绘制的内容 123456/** 旋转画布到指定角度（0度 开始旋转）0度在最右位置 */public void rotate (float degrees)/** 已传入点为中心旋转画布到指定角度（0度 开始旋转）0度在最右位置 */public final void rotate (float degrees, float px, float py) 保存画布保存当前的画布操作及属性 1public int save () 缩放 123456public final void scale (float sx, float sy, float px, float py)public void scale (float sx, float sy) 平移 12public void translate (float dx, float dy) Bitmap指定绘画路径、曲线、文字或图片(Rect、Path、Text、Bitmap等) Rect 在绘制曲线、圆、矩形时，可以通过指定绘制区域Rect的方式，简化绘制参数的传入；例如：在绘制弧形曲线时,Canvas类提供了如下两种方法，在你想画不是特别复杂的圆弧时，我想第二种方法应该是最简单、易用得啦！ 12345678910111213public void drawArc (float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint)public void drawArc (RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint) 第二种方法中的RectF参数即为控制绘画曲线区域的数据类型； 画笔（Paint） 你好","categories":[{"name":"Android","slug":"Android","permalink":"https://lisunny.github.io/categories/Android/"}],"tags":[{"name":"Canvas","slug":"Canvas","permalink":"https://lisunny.github.io/tags/Canvas/"},{"name":"自定义绘制","slug":"自定义绘制","permalink":"https://lisunny.github.io/tags/自定义绘制/"}]},{"title":"1k卡的开发实践","slug":"1k卡的开发实践","date":"2019-09-06T07:56:32.000Z","updated":"2019-09-09T03:48:11.755Z","comments":true,"path":"2019/09/06/1k卡的开发实践/","link":"","permalink":"https://lisunny.github.io/2019/09/06/1k卡的开发实践/","excerpt":"","text":"最近工作需要学习了下AndroidNFC开发，主要是M1卡信息读取；简单的卡读取当然是没有任何难度，百度一堆代码，拿来就能用；本次的难点主要在后端给定keyA，然后通过keyA读取指定扇区的数据；功能不难，但由于不了解M1卡同时没有深入理解NDEF数据格式，导致在开发过程中浪费了不少时间，所以记录下，以备遗忘； 什么是NFC? NFC(Near Field Communication)即近距离无线通讯技术。2003年由飞利浦公司和索尼公司共同开发，它是一种非接触式识别和互联技术。 NFC卡都有哪些种类？关于Mifare 1k卡你需要了解的相关信息M1卡的内存结构 M1卡共16个扇区 每个扇区有4个数据块 每个扇区的最后一个数据块并不保存数据 0扇区的0数据块比较特殊，一般出厂写入且不可修改。（特殊的可无限擦写的UID CUID卡除外）","categories":[{"name":"Android","slug":"Android","permalink":"https://lisunny.github.io/categories/Android/"}],"tags":[{"name":"NFC","slug":"NFC","permalink":"https://lisunny.github.io/tags/NFC/"},{"name":"M1卡","slug":"M1卡","permalink":"https://lisunny.github.io/tags/M1卡/"}]}]}